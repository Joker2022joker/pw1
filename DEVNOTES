Cooperative Password Keeper
===========================

because it cooperates with other programs and therefore also with the user.
	... umm, and because i couldn't come up with a better name

A "generic" password keeper that offers/requires you to do the encryption,
asking you for password, managing your authenticated session or storing
pictures of cute cats securely is broken by design.

A few notes for start:
	currently, node paths and attributes names are not encrypted in the wallet
	cpk is currently regarded as prototype only and highly experimental
	if you do want use cpk, you are advised to use vcs on the wallet after every use of cpk and check model.py for incompatible changes

How does it work?
=================

The idea is essentialy that any password can be attached to node in
a graph where the path from root node to the leaf node accurately identifies any
kind of resource the password belongs to while letting you care about the nodes semantics

It does not do any encryption/decryption by itself. It uses only your existing
infrastructure to do this. However, currently is supported only gnupg.

Fundamental data
================
    Basicly we need to store (resource_id,password)
      where
          resource_id = 1*n ( Node )

    Node = (type, name)
      where
          name = ALPHA | DIGIT
          type = Attribute.id

    Attribute = (name,type)
       where
            name = ALPHA | DIGIT
            short_name = ALPHA | DIGIT
            type = "chained" | "additional" ;

                ; chained may follow each other
                ; additional must occur only once on a path
                ; this may be completely replaced with parent type restrictions

        can be eg.
          chained = [arbitrary_resource,domain]
          additional = [user,scheme,attribute]

    Then we can have graphs
      arbitrary_resource -> arbitratry_resource -> password
      arbitrary_resource -> domain -> domain -> domain -> scheme -> user -> password

.. ffs, why does there has to be empty line to get rid off README.rst:42: (ERROR/3) Unexpected indentation.
   and why

Command Types
=============
Commands can be separated to those which
    create filters just from command line node path
        These translates node path as expected

        these are:
            mv
            rm
            list
            set

    attach attribute_type filter
        these are little tricky in that if node path does not end with attr= a filter is added to get commonly wanted result
        so if you wanna go for the password, but identify the last node just by attribute type, you need to specify password_type= explicitly

        these are:
            new <nodes>
                default password_attr= is attached when searching for the goal node

            get <nodes>
                an empty filter is added, which means getting the next child of the node path specified (currently assumes password has no siblings)

    not applicable to:
        info

TODO
====
    consistency
        same things, usage depends on context:
            nodes, filters
            attributes, node types

    Switch to markdown

    "Ask before taking an action" option

    Use DFS for the first ordered part and BFS for the second unordered

    Passwords of different strengths could be generated
        eg. some passwords is good to remember well

        this would require having Attributes Inheration and configurable Value Generator per Attribute

    automatic aliasing
        eg. lets consider graph
            org1 - "urls" - domain1
            org2 - "urls" - domain2

        then we want to have automatic aliases
            urls - domain1 -> org1 - urls domain1
            urls - domain2 -> org2 - urls domain2

    move/rename/del command

    paths aliasing
        eg. path "url com example www john_doe" can also be accessed with path "iana ldap john_doe"

    tab-completion on node paths

    node globbing

    after_save hook
        for commiting changes with dvcs?
            which in this case would probably be better use a nosql db in a file

    integration with browser form-fillers
        not really part of _this_ project

    handle copy-pasting
        using external utility like xsel will do for a while but is unsafe
        find a way how to handle this with cpk itself

    lock memory against swapping
        kinda moot on encrypted swap

    write unit/integration tests

    use fixtures in tests instead of realying on their order

    figure out how to encrypt whole db on exit and decrypt the db on start of program and feed the decrypted data into memory db

    Try to use a graph lib for the heavy work [1]_

Implementation notes, drafts, etc
==================================
    aliases
        just creating an edge as an alias wont do as if we had A - B - C and D - E where B would have an edge to E, A - B - E - X and D - E - X would resolve to the same object.
        Thats not what i am looking for.

        Aliases is rather external to the graph. It is list of tuple (node A, node B) saying that when a child of A occurs, it should also be child of B



    attributes could be restricted to be allowed only to follow certain types of attributes
        eg. most attributes cant follow password but attribute eg. "comment" could

Sources
=======
.. [1] http://wiki.python.org/moin/PythonGraphApi

